name: Auto-approve trusted comments

on:
  pull_request:
    types: [opened]
    paths:
      - 'data/comments/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-approve:
    runs-on: ubuntu-latest
    # Only run for PRs that modify comment files
    if: contains(github.event.pull_request.title, 'comment')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check if email is trusted
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Get the files changed in this PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            // Find the comment JSON file
            const commentFile = files.find(f =>
              f.filename.startsWith('data/comments/') && f.filename.endsWith('.json')
            );

            if (!commentFile) {
              core.setOutput('approved', 'false');
              core.info('No comment file found in PR');
              return;
            }

            // Fetch the file content from the PR branch
            const { data: content } = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: commentFile.filename,
              ref: context.payload.pull_request.head.sha,
            });

            const comment = JSON.parse(Buffer.from(content.content, 'base64').toString());
            const emailHash = comment.email; // Already MD5-hashed by Staticman transforms

            if (!emailHash) {
              core.setOutput('approved', 'false');
              core.info('No email hash found in comment');
              return;
            }

            // Load the approved emails list
            let approvedEmails = [];
            try {
              approvedEmails = JSON.parse(fs.readFileSync('data/approved-emails.json', 'utf8'));
            } catch {
              core.info('Could not read approved-emails.json');
            }

            const isTrusted = approvedEmails.includes(emailHash);
            core.setOutput('approved', isTrusted ? 'true' : 'false');
            core.info(`Email hash: ${emailHash}`);
            core.info(`Trusted: ${isTrusted}`);

      - name: Auto-merge if trusted
        if: steps.check.outputs.approved == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            // Merge the PR directly (no approval needed for own repo)
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              merge_method: 'squash',
              commit_title: `Auto-merge comment: ${context.payload.pull_request.title}`,
            });

      - name: Label for manual review
        if: steps.check.outputs.approved == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: ['needs-review'],
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: 'This comment is from a new email address and requires manual review. To approve future comments from this email, add the MD5 hash to `data/approved-emails.json` after merging.',
            });
